## 跨域及其解决方法



### 什么是跨域

跨域是指一个域下的文档或者脚本试图去请求另一个域下的资源，这里跨域是广义的。

广义的跨域：

- 资源跳转：链接、重定向、表单提交
- 资源嵌入：<link>、<script>、<img>、<frame>等dom标签，还有样式中的background:url()、@font-face()等文件外链
- 脚本请求：js发起的ajax请求、dom和js对象的跨域操作等

### 为什么会出现跨域

（我们通常所说的跨域是狭义的，）是由浏览器的同源策略限制的一类请求场景。

同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能。如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。

所谓同源就是两个页面具有相同的协议（protocol）、主机（host）和端口号（port）。

即便两个不同的域名指向同一个ip地址，也非同源。

### 非同源限制

【1】无法读取非同源网页的 Cookie、LocalStorage和IndexedDB

【2】无法获得非同源网页的DOM和JS对象

【3】无法向非同源地址发送AJAX请求

### 常见的跨域场景

| URL                                                          | 说明                     | 是否允许通信 |
| ------------------------------------------------------------ | ------------------------ | ------------ |
| http://www.domain.com/a.js<br />http://www.domain.com/b.js<br />http://www.domain.com/lab/c.js | 同一域名，不同文件或路径 | 允许         |
| http://www.domain.com:8080/a.js<br />http://www.domain.com/b.js | 同一域名，不同端口       | 不允许       |
| http://www.domain.com/a.js<br />https://www.domain.com/b.js  | 同一域名，不同协议       | 不允许       |
| http://www.domain.com/a.js<br />http://192.168.1.18/b.js     | 域名和域名对应相同的ip   | 不允许       |
| http://www.domain.com/a.js<br />http://x.domain.com/b.js<br />http://domain.com/c.js | 主域相同，子域不同       | 不允许       |
| http://www.domain1.com/a.js<br />http://www.domain2.com/b.js | 不同域名                 | 不允许       |

### 跨域解决方案

- **设置document.domain解决无法读取非同源网页的Cookie问题**
  实现原理：浏览器是通过document.domain属性来检查两个页面是否同源，两个页面都通过js强制设置document.domain为基础主域，就实现了同域，两个页面就可以共享Cookie。

  ```html
  <!-- 父窗口：http://www.domain.com/a.html -->
  <iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
  <script>
    document.domain = 'domain.com';
    var user = 'admin';
  </script>
  
  <!-- 子窗口：http://child.domain.com/b.html -->
  <script>
    document.domain = 'domain.com';
  	// 获取父窗口中变量
    alert('get js data from parent' + window.parent.user);
  </script>
  ```

- **跨文档通信API：window.postMessage()**
  postMessage是HEML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一
  它可用于解决以下方面的问题

  - 页面和其打开的新窗口的数据传递
  - 多窗口之间消息传递
  - 页面与嵌套的iframe消息传递
  - 上面三个场景的跨域数据传递

  用法：postMessaage(data, origin)方法接受两个参数

  - data：html5类型支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化
  - origin：协议+主机+端口号，也可以设置为“*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为“/”。

  ```html
  <!-- iframe example -->
  <!-- a.html：http://www.domain1.com/a.html -->
  <iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
  <script>
    var iframe = document.getElementById('iframe');
    iframe.onload = function() {
      var data = {
        name: 'admin'
      };
      // 向domain2传送跨域数据
      iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');
    };
    
    // 接受domain2的返回数据
    window.addEventListener('message', function(e) {
      alert('data from domain2 ---> ' + e.data);
    }, false);
  </script>
  
  <!-- b.html：http://www.domain2.com/b.html -->
  <script>
  	// 接收domain1的数据
    window.addEventListener('message', function(e) {
      alert('data from domain1 ---> ' + e.data);
      var data = JSON.parse(e.data);
      if(data) {
        data.sex = 1;
        window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');
      }
    }, false);
  </script>
  ```

  ```html
  <!-- 窗口 example -->
  <!-- 父窗口 -->
  <script>
    // 父窗口打开一个子窗口
    var openWindow = window.open('http://test2.com', 'title');
    // 父窗口向子窗口发消息
    openWindow.postMessage('Nice to meet you!', 'http://test2.com');
  </script>
  
  <!-- 子窗口 -->
  <script>
    // 监听 message 消息
    window.addEventListener('message', function(e) {
      console.log(e.source); // e.source 发送消息的窗口
      console.log(e.origin); // e.origin 消息发向的网址
      console.log(e.data); // e.data 发送的消息
    }, false);
  </script>
  ```

- **JSONP**
  JSONP是服务器与客户端跨域通信的常用方法。最大的特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。
  通常为了减轻web服务器的负载，我们把js、css、img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，在请求一个带参网址实现跨域通信。

  ```html
  <!-- 原生实现 -->
  <script>
    var script = document.createElement('script');
    script.type = "text/javascript";
    
    // 传一个回调参数给后端，方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
    document.head.appendChild(script);
    
    // 回调执行函数
    function handleCallback(res) {
      alert(JSON.stringify(res));
    }
  </script>
  
  // 服务端返回如下（返回时即执行全局函数）
  handleCallback({
  	"status": true,
  	"user": "admin"
  })
  ```

  ```js
  // jquery ajax
  $.ajax({
    url: 'http://www.domain2.com:8080/login',
    type: 'get',
    dataType: 'jsonp', // 请求方式为jsonp
    jsonpCallback: "handleCallback", //自定义回调函数名
    data: {}
  });
  ```

  ```js
  // vue.js
  this.$http.jsonp('http://www.domain2.com:8080/login', {
    params: {},
    jsonp: "handleCallback"
  }).then((res) => {
    console.log(res);
  })
  ```

  ```js
  // 后端nodejs代码示例
  var querystring = require('querystring');
  var http = require('http');
  var server = http.createServer();
  
  server.on('request', function(req, res) {
    var params = qs.parse(req.url.split('?')[1]);
    var fn = params.callback;
    
    // jsonp返回设置
    res.writeHead(200, { 'Content-Type': 'text/javascript' });
    res.write(fn + '(' + JSON.stringify(params) + ')');
    
    res.end();s
  })
  
  server.listen('8080');
  console.log('Server is running at port 8080...');
  ```

- CORS
  CORS是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，属于跨域AJAX请求的根本解决方法。

  - 普通跨域请求：只需服务端设置Access-Control-Allow-Origin
  - 带cookie跨域请求：前后端都需要进行设置

  目前所有浏览器都支持该功能（IE8+：IE8/9需要使用xDomainRequest对象来支持CORS）， CORS也已经成为主流的跨域解决方案。

  需要注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：**nginx反向代理中设置proxy_cookie_domain**、**NodeJS中间件代理中cookieDomainRewrite参数的设置**

  - 前端设置

    ```js
    // 原生 ajax
    
    var xhr = new XMLHttpRequest(); // IE8/9需要使用xDomainRequest对象来兼容
    
    // 前端设置是否带cookie
    xhr.withCredentials = true;
    
    xhr.open('post', 'http://www.domain2.com:8080/login', true);
    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    xhr.send('user=admin');
    
    xhr.onreadystatechange = function() {
      if(xhr.readyState == 4 && xhr.status == 200) {
        alert(xhr.responseText);
      }
    };
    ```

    ```js
    // jQuery ajax
    $.ajax({
      ...
      xhrFields: {
        withCredentials: true // 前端设置是否带cookie
      },
      crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie
      ...
    });
    ```

    ```js
    // vue框架
    
    // axios设置
    axios.defaults.withCredentials = true
    
    // vue-resource设置
    Vue.http.options.credentials = true
    ```

  - 服务端设置
    若后端设置成功，前端浏览器控制台则不会出现跨域报错信息。

    ```java
    // Java后台
    /*
     * 导入包：import javax.servlet.http.HttpServletResponse;
     * 接口参数中定义：HttpServletResponse response
     */
    
    // 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加'/'
    response.setHeader("Access-Control-Allow-Origin", "http://www.domain1.com"); 
    
    // 允许前端带认证cookie：启用此项后，上面的域名不能为'*'，必须指定具体的域名，否则浏览器会提示
    response.setHeader("Access-Control-Allow-Credentials", "true"); 
    
    // 提示OPTIONS预检时，后端需要设置的两个常用自定义头
    response.setHeader("Access-Control-Allow-Headers", "Content-Type,X-Requested-With")
    ```

    ```js
    // Nodejs后台
    var http = require('http');
    var server = http.createServer();
    var qs = require('querystring');
    
    server.on('request', function(req, res) {
        var postData = '';
    
        // 数据块接收中
        req.addListener('data', function(chunk) {
            postData += chunk;
        });
    
        // 数据接收完毕
        req.addListener('end', function() {
            postData = qs.parse(postData);
    
            // 跨域后台设置
            res.writeHead(200, {
                'Access-Control-Allow-Credentials': 'true',     // 后端允许发送Cookie
                'Access-Control-Allow-Origin': 'http://www.domain1.com',    // 允许访问的域（协议+域名+端口）
                /* 
                 * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，
                 * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问
                 */
                'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'  // HttpOnly的作用是让js无法读取cookie
            });
    
            res.write(JSON.stringify(postData));
            res.end();
        });
    });
    
    server.listen('8080');
    console.log('Server is running at port 8080...');
    ```

    ```php
    // PHP后台
    <?php
     header("Access-Control-Allow-Origin:*");
    ```

    ```js
    // Apache需要使用mod_headers模块来激活HTTP头的设置，它默认是激活的。你只需要在Apache配置文件的<Directory>, <Location>, <Files>或<VirtualHost>的配置里加入以下内容即可
    
    Header set Access-Control-Allow-Origin *
    ```

- [更多跨域解决方案详见](https://segmentfault.com/a/1190000011145364)

