### js继承的6种方式

想要继承，就必须要提供个父类（继承谁，提供继承的属性）

```js
// 父类
function Person(name){// 给构造函数添加了参数
  this.name = name;
  this.sum = function() {
    alert(this.name);
  }
}
Person.prototype.age = 10;// 给构造函数添加了原型属性
```

一、原型链继承

```js
// 原型链继承
function Per(){
  this.name = "ljm"
}
Per.prototype = new Person()
var per1 = new Per()
// instanceof 判断元素是否在另一个元素的原型链上
console.log(per1 instanceof Person) // per1继承了per的属性，返回 ture
```

重点：让新实例的原型等于父类的实例。
特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）缺点：1、新实例无法向父类构造函数传参。
　　　2、继承单一。
　　　3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）
　　
二、借用构造函数继承
　 ![img](https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162125772-1830945749.png)
　　　　重点：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制）)
　　　　特点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。
　　　　　　　2、解决了原型链继承缺点1、2、3。
　　　　　　　3、可以继承多个构造函数属性（call多个）。
　　　　　　　4、在子实例中可向父实例传参。
　　　　缺点：1、只能继承父类构造函数的属性。
　　　　　　　2、无法实现构造函数的复用。（每次用每次都要重新调用）
　　　　　　　3、每个新实例都有父类构造函数的副本，臃肿。

　　三、组合继承（组合原型链继承和借用构造函数继承）（常用）
　　　　 ![img](https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162137084-1234623120.png)
　　　　重点：结合了两种模式的优点，传参和复用
　　　　特点：1、可以继承父类原型上的属性，可以传参，可复用。
　　　　　　　2、每个新实例引入的构造函数属性是私有的。
　　　　缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。

　　四、原型式继承
　　　　 ![img](https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162147596-1363486586.png)
　　　　重点：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。
　　　　特点：类似于复制一个对象，用函数来包装。
　　　　缺点：1、所有实例都会继承原型上的属性。
　　　　　　　2、无法实现复用。（新实例属性都是后面添加的）
　　
　　五、寄生式继承
　　　　 ![img](https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162158915-1866300593.png)
　　　　重点：就是给原型式继承外面套了个壳子。
　　　　优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。
　　　　缺点：没用到原型，无法复用。
　　　　
　　六、寄生组合式继承（常用）
　　　　寄生：在函数内返回对象然后调用
　　　　组合：1、函数的原型等于另一个实例。2、在函数中用apply或者call引入另一个构造函数，可传参　
　　　　 ![img](https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162220285-1478888936.png)
　　　　重点：修复了组合继承的问题

　　　　继承这些知识点与其说是对象的继承，更像是函数的功能用法，如何用函数做到复用，组合，这些和使用继承的思考是一样的。上述几个继承的方法都可以手动修复他们的缺点，但就是多了这个手动修复就变成了另一种继承模式。
　　　　这些继承模式的学习重点是学它们的思想，不然你会在coding书本上的例子的时候，会觉得明明可以直接继承为什么还要搞这么麻烦。就像原型式继承它用函数复制了内部对象的一个副本，这样不仅可以继承内部对象的属性，还能把函数（对象，来源内部对象的返回）随意调用，给它们添加属性，改个参数就可以改变原型对象，而这些新增的属性也不会相互影响。